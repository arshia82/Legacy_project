from decimal import Decimal, ROUND_HALF_UP
import time
import secrets
import hashlib

# ============================================================
# COMMISSION RULES
# ============================================================

MIN_COMMISSION = Decimal("1")  # 1 toman floor


def calculate_commission(amount, user):
    """
    Calculates commission based on per-user rate.
    """
    amount = Decimal(amount)

    if amount <= 0:
        return Decimal("0")

    rate = user.commission_rate or Decimal("0.12")

    fee = (amount * rate).quantize(
        Decimal("1."), rounding=ROUND_HALF_UP
    )

    return max(fee, MIN_COMMISSION)


# ============================================================
# TRUST TOKEN (ANTI-FRAUD / WORKFLOW LOCK)
# ============================================================

def generate_trust_token(user_id: int, action: str, ttl: int = 3600):
    """
    Generates a short-lived trust token for sensitive actions
    (verification submit, approval, payout, delivery).
    """
    expires_at = int(time.time()) + ttl
    nonce = secrets.token_hex(8)

    raw = f"{user_id}:{action}:{expires_at}:{nonce}"
    signature = hashlib.sha256(raw.encode()).hexdigest()

    return raw, signature


def validate_trust_token(
    raw: str,
    signature: str,
    expected_user_id: int | None = None,
    expected_action: str | None = None,
):
    """
    Validates a trust token generated by generate_trust_token.

    Returns:
        dict with parsed token data on success

    Raises:
        ValueError on invalid or expired token
    """
    expected_sig = hashlib.sha256(raw.encode()).hexdigest()
    if not secrets.compare_digest(expected_sig, signature):
        raise ValueError("Invalid trust token signature")

    try:
        user_id_str, action, expires_at_str, _nonce = raw.split(":", 3)
        user_id = int(user_id_str)
        expires_at = int(expires_at_str)
    except Exception:
        raise ValueError("Malformed trust token")

    if time.time() > expires_at:
        raise ValueError("Trust token expired")

    if expected_user_id is not None and user_id != expected_user_id:
        raise ValueError("Trust token user mismatch")

    if expected_action is not None and action != expected_action:
        raise ValueError("Trust token action mismatch")

    return {
        "user_id": user_id,
        "action": action,
        "expires_at": expires_at,
    }